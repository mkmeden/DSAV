/// <reference types="react" />
import { BinaryTreeCheckType } from '../types';
export declare class Node {
    value: number;
    left: Node;
    right: Node;
    parent: Node;
    leftJSX: JSX.Element;
    rightJSX: JSX.Element;
    currentJSX: JSX.Element;
    constructor(value: number);
    insert(node: Node, isLeft: boolean): void;
    setJSX(): void;
    updateRootJSX(): void;
    setChildToNull(isLeft: boolean): void;
    setChildToChildsChild(isLeftChild: boolean, isLeft: boolean): void;
    remove(childrenCondtion: string): void;
    updateValue(value: number): void;
    addHighlight(): void;
    clearHighlight(): void;
    balanceJSX(): void;
}
declare class BST {
    root: Node;
    highlightedNode: Node;
    leafDepth: number;
    constructor(num?: number);
    insert(value: number): void;
    insertNode(node: Node, newNode: Node): void;
    findMax(node?: Node): Node;
    findMin(node?: Node): Node;
    remove(value: number): void;
    removeNode(node: Node, value: number): Node;
    height(node?: Node): number;
    countNodes(node?: Node): number;
    preorder(list: number[], node?: Node): void;
    inorder(list: number[], node?: Node): void;
    postorder(list: number[], node?: Node): void;
    search(value: number, node?: Node): boolean;
    generateRandomBST(num: number): void;
    checkBST(): BinaryTreeCheckType[];
    isBalanced(node?: Node): boolean;
    isComplete(): boolean;
    isComplete2(index: number, totalNodes: number, node?: Node): boolean;
    isPerfect(): boolean;
    isPerfect2(node?: Node, depth?: number): boolean;
    isFull(node?: Node): boolean;
    balance(node?: Node): void;
    BSTToArr(node: Node, nodes: Node[]): void;
    makeBST(nodes: Node[], start: number, end: number): void;
    clearHighlight(): void;
}
export default BST;
